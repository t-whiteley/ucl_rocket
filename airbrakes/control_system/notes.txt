Descrpiption of current implementation
1. filter noise using const a. kalman filter -> measure (h, a), estimate (h, v, a)
2. esimtate current apogee -> numerical differential eq solver (4th order runge-kutta)
3. control system -> difference in ap_pred and ap_des to a PID and servo signal
4. file descriptions
	* main.py is what gets executed, it is the airbrake control system loop running during flight and how the model should be run: "python3 main.py"
	* apogee.py estimates apogee given current conditions using runge-kutta
	* _model.py is a model for the sensor, it is a model that generates sensor data that feeds to:
	* _flightcomp.py is a model for the main flight computer, it takes care of sensor fusion and noise filterring to give valid data to main.py
	* _kf.py is a basic constant acceleration kalman filter for a 1d model, to be replaced (const accel approx becomes valid near apogee)


TODO
(PRIORITY)	- improve from 1d to 3d model -> modules for sensor fusion - kalman??
(PRIORITY)	- use the rocketpy package for a better model of the rocket
			- improve kinematics of model: rocket loses mass, Cd from cfd, all params
			- make control system modelled to the dynamics of the system - may need cfd for cd
			- optimise everywhere, CFD tables, lookup tables, algorithms
(FUTURE)	- AI for self-tuning PID controller??

sources:
Application of the Kalman Filter to Rocket Apogee Detection By David W. Schultz
Barometric Apogee Detection Using the Kalman Filter By David W. Schultz
Quaternion kinematics for the error-state Kalman filter Joan Sola






Plan to move from 1d to 3d -> gyro
* sensor fusion algorithms: ahrs (for orientation): kalman/madgwick/complimentary
* coordinate systems to be familiar with: euler angles, quaternions or DCM
* steps
	* find g vector using accel readings - calibrate at 0 and assume vertical at t=0
	* use baro + 6DOF IMU for a kalman filter
	* find quaternions and euler angles using (madgwick from raw IMU) (or kalman??)
	* maybe implement low pass filter before kf?


Q
* i might not need gyro, i can just calibrate and take the negative of the g vector